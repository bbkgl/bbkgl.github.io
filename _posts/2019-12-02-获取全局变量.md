---
layout:     post
title:      获取其他进程的全局变量
subtitle:   profile
date:       2019-12-02
author:     bbkgl
header-img: img/post-bg-0007.jpg
catalog: true
tags:
    - profile
---

>微微风簇浪
>
>散作满河星

如何获取存储在bss段上的，未初始化的“其他进程”的全局变量？

首先考虑到的是使用ptrace，但是ptrace获取其他进程的全局变量，需要该变量的地址。

那如何得到对应bss段变量的地址呢？

使用对应程序段的起始地址+变量的地址偏移量，接下来进行验证和说明。

这里先贴出被测试的程序：

```cpp
#include <cstdio>
#include <iostream>
#include <unistd.h>

struct temp {
    int a;
    int b;
    int c;
};

temp g_test;
int test = 1;


void func() {
    printf("0x%016lx\n", &g_test);
    sleep(100000);
}

int main() {
    printf("%d\n", getpid());
    func();
    return 0;
}
```

## 变量的地址以及调试信息

#### 调试符号

> 可以参考[符号表](<https://www.cnblogs.com/chenxuming/articles/9706161.html>)
>
> [关于elf中的st_value](<https://blog.csdn.net/farmwang/article/details/72848058>)，**一定要看，很重要！！！！**

关于调试信息，可以自行查资料，目前比较常用的就是dwarf，也就是在编译程序的时候加上-g选项，就能在对应可执行文件中加入符号信息。

linux下查看调试符号可以通过`readelf`和`objdump`两个工具。

如果使用`readelf -s <exename>`会打印出所有符号的信息：

![](https://ae01.alicdn.com/kf/H75098c05a7404b5f868bd18fd4341b38T.jpg)

如果需要找到对应变量的信息，可以直接`grep`，比如我使用`readelf -s testo | grep g_test`：

![](https://ae01.alicdn.com/kf/H30354019899b496d96a80a34953942c55.jpg)

其中value有可能是偏移量，也有可能就是绝对地址。

**目前关于st_value**的值，因为我们查看的就是elf可执行文件，所以实际上该地址就是内存中的虚拟地址。

特别是对于全局变量来说，无论在.data段还是.bss段，都是在编译后就确定了其虚拟地址，后面会进行验证和分析。

#### 地址范围

程序运行后，代码加载进入内存，并打印结果：

![](https://ae01.alicdn.com/kf/H5baf319917254901a8409c4535c0bc302.jpg)

第一行是进程id，第二行是未初始化的全局变量`g_test`的地址，然后再使用gdb attach到目标进程中，可以查找到已经初始化的`test`全局变量的地址：

![](https://ae01.alicdn.com/kf/Heaf48dd313d0410a812048b7cf168bdaC.jpg)

同时会在`/proc/<pid>/maps`文件中存储下每个段的地址范围：

![](https://ae01.alicdn.com/kf/Hf5f692c25b1646ef980791ffa3427239i.jpg)

每一行前面表示的是地址范围和读写权限等信息，最后表示的是文件名。

主要关注前四行和倒数第四行，行数从大到小（内存由低到高）分别表示：

- 第一行代码段，因为只读+可执行
- 第二行我也不知道23333
- 第三行是data+bss段，根据前面打印的初始化以及未初始化的全局变量的地址，可以看到是吻合的
- 第四行是堆地址
- 还有倒数第四行是栈地址

说这么多，基本就是想说明，我们可以通过调试信息得到全局变量的地址，无论是bss段还是data段，然后就能使用ptrace读取些变量的值，下面进行实践和验证。

## 获取进程中全局变量的值

关于ptrace，相关的博客介绍很多，