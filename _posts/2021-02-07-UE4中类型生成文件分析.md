---
clayout:     post
typora-root-url: ..
title:      UE4中C++类型生成文件分析
subtitle:   反射类型分析，生成文件分析
date:       2021-02-07
author:     bbkgl
header-img: img/post-bg-0018.jpg
catalog: true
tags:
    - UE4
    - C++
---

> 我有故人抱剑去
>
> 斩尽春风未肯归

要解释UE4 C++中的反射，很难不讲或者少讲生成文件（\*.generated.h 和 \*.gen.cpp）。这是对于开发者来说，最直接能接触到的部分，也是研究引擎中C++动态实现最

因为生成代码中有大量的宏，初见时让我觉得这不是给人看的23333。。。

但一点点跟着知乎上的教程，还是硬着头皮啃下来了，然后一一展开所有宏，揭开这个反射系统最外层的面纱。

本文仅对提供简单的例子对类型生成文件进行解释，详细的生成文件的解析可以参考 [UE4 UObject反射系列](https://zhuanlan.zhihu.com/p/75533335) 以及 [Inside UE4](https://www.zhihu.com/column/insideue4) 。

### 生成文件展开

#### 简单的示例类

首先在UE4中新建一个类，名字应该尽量短。。。否则会造成阅读困难，眼花缭乱。

HH.h

```cpp
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "UObject/NoExportTypes.h"
#include "HH.generated.h"

/**
 * 
 */
UCLASS()
class CCREFLECTION_API UHH : public UObject
{
	GENERATED_BODY()

public:
	UFUNCTION(BlueprintCallable)
	int HHFunc(int a);

	UPROPERTY()
	int HHID;
	
};
```

HH.cpp

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "HH.h"

int UHH::HHFunc(int a)
{
}
```

`GENERATED_BODY()` 宏进行了拼接。

```
   GENERATED_BODY()
-> BODY_MACRO_COMBINE()
...
-> CURRENT_FILE_ID##_##__LINE__##_GENERATED_BODY
```

其中 `CURRENT_FILE_ID` 在 `*.generated.h` 中定义。

![1612949922211](/cloud_img/1612949922211.png)

所以`GENERATED_BODY()` 宏展开后即：

```cpp
CCReflection_Source_CCReflection_HH_h_15_GENERATED_BODY
```

而 `UCLASS()` 、`UFUNCTION()` 、`UPROPERTY()` 的作用更多的是作为UHT分析代码的一种修饰标志，即表示被修饰的类、属性或者函数要支持反射。

#### HH.generated.h

**分析生成文件的内容，首先是HH.generated.h。**

HH.generated.h

```cpp
#include "UObject/ObjectMacros.h"
#include "UObject/ScriptMacros.h"

PRAGMA_DISABLE_DEPRECATION_WARNINGS
#ifdef CCREFLECTION_HH_generated_h
#error "HH.generated.h already included, missing '#pragma once' in HH.h"
#endif
#define CCREFLECTION_HH_generated_h

#define CCReflection_Source_CCReflection_HH_h_15_SPARSE_DATA
#define CCReflection_Source_CCReflection_HH_h_15_RPC_WRAPPERS \
 \
	DECLARE_FUNCTION(execHHFunc);


#define CCReflection_Source_CCReflection_HH_h_15_RPC_WRAPPERS_NO_PURE_DECLS \
 \
	DECLARE_FUNCTION(execHHFunc);


#define CCReflection_Source_CCReflection_HH_h_15_INCLASS_NO_PURE_DECLS \
private: \
	static void StaticRegisterNativesUHH(); \
	friend struct Z_Construct_UClass_UHH_Statics; \
public: \
	DECLARE_CLASS(UHH, UObject, COMPILED_IN_FLAGS(0), CASTCLASS_None, TEXT("/Script/CCReflection"), NO_API) \
	DECLARE_SERIALIZER(UHH)


#define CCReflection_Source_CCReflection_HH_h_15_INCLASS \
private: \
	static void StaticRegisterNativesUHH(); \
	friend struct Z_Construct_UClass_UHH_Statics; \
public: \
	DECLARE_CLASS(UHH, UObject, COMPILED_IN_FLAGS(0), CASTCLASS_None, TEXT("/Script/CCReflection"), NO_API) \
	DECLARE_SERIALIZER(UHH)


#define CCReflection_Source_CCReflection_HH_h_15_STANDARD_CONSTRUCTORS \
	/** Standard constructor, called after all reflected properties have been initialized */ \
	NO_API UHH(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get()); \
	DEFINE_DEFAULT_OBJECT_INITIALIZER_CONSTRUCTOR_CALL(UHH) \
	DECLARE_VTABLE_PTR_HELPER_CTOR(NO_API, UHH); \
DEFINE_VTABLE_PTR_HELPER_CTOR_CALLER(UHH); \
private: \
	/** Private move- and copy-constructors, should never be used */ \
	NO_API UHH(UHH&&); \
	NO_API UHH(const UHH&); \
public:


#define CCReflection_Source_CCReflection_HH_h_15_ENHANCED_CONSTRUCTORS \
	/** Standard constructor, called after all reflected properties have been initialized */ \
	NO_API UHH(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get()) : Super(ObjectInitializer) { }; \
private: \
	/** Private move- and copy-constructors, should never be used */ \
	NO_API UHH(UHH&&); \
	NO_API UHH(const UHH&); \
public: \
	DECLARE_VTABLE_PTR_HELPER_CTOR(NO_API, UHH); \
DEFINE_VTABLE_PTR_HELPER_CTOR_CALLER(UHH); \
	DEFINE_DEFAULT_OBJECT_INITIALIZER_CONSTRUCTOR_CALL(UHH)


#define CCReflection_Source_CCReflection_HH_h_15_PRIVATE_PROPERTY_OFFSET
#define CCReflection_Source_CCReflection_HH_h_12_PROLOG
#define CCReflection_Source_CCReflection_HH_h_15_GENERATED_BODY_LEGACY \
PRAGMA_DISABLE_DEPRECATION_WARNINGS \
public: \
	CCReflection_Source_CCReflection_HH_h_15_PRIVATE_PROPERTY_OFFSET \
	CCReflection_Source_CCReflection_HH_h_15_SPARSE_DATA \
	CCReflection_Source_CCReflection_HH_h_15_RPC_WRAPPERS \
	CCReflection_Source_CCReflection_HH_h_15_INCLASS \
	CCReflection_Source_CCReflection_HH_h_15_STANDARD_CONSTRUCTORS \
public: \
PRAGMA_ENABLE_DEPRECATION_WARNINGS


#define CCReflection_Source_CCReflection_HH_h_15_GENERATED_BODY \
PRAGMA_DISABLE_DEPRECATION_WARNINGS \
public: \
	CCReflection_Source_CCReflection_HH_h_15_PRIVATE_PROPERTY_OFFSET \
	CCReflection_Source_CCReflection_HH_h_15_SPARSE_DATA \
	CCReflection_Source_CCReflection_HH_h_15_RPC_WRAPPERS_NO_PURE_DECLS \
	CCReflection_Source_CCReflection_HH_h_15_INCLASS_NO_PURE_DECLS \
	CCReflection_Source_CCReflection_HH_h_15_ENHANCED_CONSTRUCTORS \
private: \
PRAGMA_ENABLE_DEPRECATION_WARNINGS


template<> CCREFLECTION_API UClass* StaticClass<class UHH>();

#undef CURRENT_FILE_ID
#define CURRENT_FILE_ID CCReflection_Source_CCReflection_HH_h

PRAGMA_ENABLE_DEPRECATION_WARNINGS
```

前面提到的`GENERATED_BODY()` 宏展开的结果就在该生成文件第79行，其再次展开后得到如下宏：

```cpp
#define CCReflection_Source_CCReflection_HH_h_15_GENERATED_BODY \
PRAGMA_DISABLE_DEPRECATION_WARNINGS \
public: \
	CCReflection_Source_CCReflection_HH_h_15_PRIVATE_PROPERTY_OFFSET \
	CCReflection_Source_CCReflection_HH_h_15_SPARSE_DATA \
	CCReflection_Source_CCReflection_HH_h_15_RPC_WRAPPERS_NO_PURE_DECLS \
	CCReflection_Source_CCReflection_HH_h_15_INCLASS_NO_PURE_DECLS \
	CCReflection_Source_CCReflection_HH_h_15_ENHANCED_CONSTRUCTORS \
private: \
PRAGMA_ENABLE_DEPRECATION_WARNINGS
```

将这些宏一一分析：

```cpp
CCReflection_Source_CCReflection_HH_h_15_PRIVATE_PROPERTY_OFFSET
CCReflection_Source_CCReflection_HH_h_15_SPARSE_DATA
```

以上这两个宏为空，略过。

展开 `CCReflection_Source_CCReflection_HH_h_15_RPC_WRAPPERS_NO_PURE_DECLS` 如下：

```cpp
CCReflection_Source_CCReflection_HH_h_15_RPC_WRAPPERS_NO_PURE_DECLS
-> DECLARE_FUNCTION(execHHFunc);
-> static void execHHFunc( UObject* Context, FFrame& Stack, RESULT_DECL );
-> static void execHHFunc( UObject* Context, FFrame& Stack, void *const Z_Param__Result);
```

展开 `CCReflection_Source_CCReflection_HH_h_15_INCLASS_NO_PURE_DECLS` 稍微麻烦，一步步展开如下：

```cpp
private: \
	static void StaticRegisterNativesUHH(); \
	friend struct Z_Construct_UClass_UHH_Statics; \
public: \
	DECLARE_CLASS(UHH, UObject, COMPILED_IN_FLAGS(0), CASTCLASS_None, TEXT("/Script/CCReflection"), NO_API) \
	DECLARE_SERIALIZER(UHH)
```

首先将 `DECLARE_CLASS` 展开：

```cpp
DECLARE_CLASS(UHH, UObject, COMPILED_IN_FLAGS(0), CASTCLASS_None, TEXT("/Script/CCReflection"), NO_API)
-> 
private: \
    UHH& operator=(UHH&&);   \
    UHH& operator=(const UHH&);   \
	NO_API static UClass* GetPrivateStaticClass(); \
public: \
	/** Bitwise union of #EClassFlags pertaining to this class.*/ \
	enum {StaticClassFlags=COMPILED_IN_FLAGS(0)}; \
	/** Typedef for the base class ({{ typedef-type }}) */ \
	typedef UObject Super;\
	/** Typedef for {{ typedef-type }}. */ \
	typedef UHH ThisClass;\
	/** Returns a UClass object representing this class at runtime */ \
	inline static UClass* StaticClass() \
	{ \
		return GetPrivateStaticClass(); \
	} \
	/** Returns the package this class belongs in */ \
	inline static const TCHAR* StaticPackage() \
	{ \
		return TEXT("/Script/CCReflection"); \
	} \
	/** Returns the static cast flags for this class */ \
	inline static EClassCastFlags StaticClassCastFlags() \
	{ \
		return CASTCLASS_None; \
	} \
	/** For internal use only; use StaticConstructObject() to create new objects. */ \
	inline void* operator new(const size_t InSize, EInternal InInternalOnly, UObject* InOuter = (UObject*)GetTransientPackage(), FName InName = NAME_None, EObjectFlags InSetFlags = RF_NoFlags) \
	{ \
		return StaticAllocateObject(StaticClass(), InOuter, InName, InSetFlags); \
	} \
	/** For internal use only; use StaticConstructObject() to create new objects. */ \
	inline void* operator new( const size_t InSize, EInternal* InMem ) \
	{ \
		return (void*)InMem; \
	}
```

然后是`DECLARE_SERIALIZER` 展开：

```cpp
	friend FArchive &operator<<( FArchive& Ar, UHH*& Res ) \
	{ \
		return Ar << (UObject*&)Res; \
	} \
	friend void operator<<(FStructuredArchive::FSlot InSlot, UHH*& Res) \
	{ \
		InSlot << (UObject*&)Res; \
	}
```

将这些部分进行合并，得到将 `GENERATED_BODY()` 宏完全展开的 HH.h 文件如下。

```cpp
UCLASS()
class CCREFLECTION_API UHH : public UObject
{
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
public:
	static void execHHFunc( UObject* Context, FFrame& Stack, void *const Z_Param__Result);
	static void execHHFunc( UObject* Context, FFrame& Stack, void *const Z_Param__Result);
private:
	PRAGMA_ENABLE_DEPRECATION_WARNINGS

private:
	static void StaticRegisterNativesUHH();
	friend struct Z_Construct_UClass_UHH_Statics;
public:
	private:
    UHH& operator=(UHH&&); 
    UHH& operator=(const UHH&); 
	NO_API static UClass* GetPrivateStaticClass(); 
public:  
	/** Bitwise union of #EClassFlags pertaining to this class.*/  
	enum {StaticClassFlags=COMPILED_IN_FLAGS(0)};  
	/** Typedef for the base class ({{ typedef-type }}) */  
	typedef UObject Super; 
	/** Typedef for {{ typedef-type }}. */  
	typedef UHH ThisClass; 
	/** Returns a UClass object representing this class at runtime */  
	inline static UClass* StaticClass()  
	{  
		return GetPrivateStaticClass();  
	}  
	/** Returns the package this class belongs in */  
	inline static const TCHAR* StaticPackage()  
	{  
		return TEXT("/Script/CCReflection");  
	}  
	/** Returns the static cast flags for this class */  
	inline static EClassCastFlags StaticClassCastFlags()  
	{  
		return CASTCLASS_None;  
	}  
	/** For internal use only; use StaticConstructObject() to create new objects. */  
	inline void* operator new(const size_t InSize, EInternal InInternalOnly, UObject* InOuter = (UObject*)GetTransientPackage(), FName InName = NAME_None, EObjectFlags InSetFlags = RF_NoFlags)  
	{  
		return StaticAllocateObject(StaticClass(), InOuter, InName, InSetFlags);  
	}  
	/** For internal use only; use StaticConstructObject() to create new objects. */  
	inline void* operator new( const size_t InSize, EInternal* InMem )  
	{  
		return (void*)InMem;  
	}

	friend FArchive &operator<<( FArchive& Ar, UHH*& Res ) \
	{ \
		return Ar << (UObject*&)Res; \
	} \
	friend void operator<<(FStructuredArchive::FSlot InSlot, UHH*& Res) \
	{ \
		InSlot << (UObject*&)Res; \
	}

public:
	UFUNCTION(BlueprintCallable)
	int HHFunc(int a);

	UPROPERTY()
	int HHID;
};
```

#### HH.gen.cpp

**接下来分析HH.gen.cpp**

HH.gen.cpp

```cpp
#include "UObject/GeneratedCppIncludes.h"
#include "CCReflection/HH.h"
#ifdef _MSC_VER
#pragma warning (push)
#pragma warning (disable : 4883)
#endif
PRAGMA_DISABLE_DEPRECATION_WARNINGS
void EmptyLinkFunctionForGeneratedCodeHH() {}
// Cross Module References
	CCREFLECTION_API UClass* Z_Construct_UClass_UHH_NoRegister();
	CCREFLECTION_API UClass* Z_Construct_UClass_UHH();
	COREUOBJECT_API UClass* Z_Construct_UClass_UObject();
	UPackage* Z_Construct_UPackage__Script_CCReflection();
// End Cross Module References
	DEFINE_FUNCTION(UHH::execHHFunc)
	{
		P_GET_PROPERTY(FIntProperty,Z_Param_a);
		P_FINISH;
		P_NATIVE_BEGIN;
		*(int32*)Z_Param__Result=P_THIS->HHFunc(Z_Param_a);
		P_NATIVE_END;
	}
	void UHH::StaticRegisterNativesUHH()
	{
		UClass* Class = UHH::StaticClass();
		static const FNameNativePtrPair Funcs[] = {
			{ "HHFunc", &UHH::execHHFunc },
		};
		FNativeFunctionRegistrar::RegisterFunctions(Class, Funcs, UE_ARRAY_COUNT(Funcs));
	}
	struct Z_Construct_UFunction_UHH_HHFunc_Statics
	{
		struct HH_eventHHFunc_Parms
		{
			int32 a;
			int32 ReturnValue;
		};
		static const UE4CodeGen_Private::FUnsizedIntPropertyParams NewProp_a;
		static const UE4CodeGen_Private::FUnsizedIntPropertyParams NewProp_ReturnValue;
		static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
	const UE4CodeGen_Private::FUnsizedIntPropertyParams Z_Construct_UFunction_UHH_HHFunc_Statics::NewProp_a = { "a", nullptr, (EPropertyFlags)0x0010000000000080, UE4CodeGen_Private::EPropertyGenFlags::Int, RF_Public|RF_Transient|RF_MarkAsNative, 1, STRUCT_OFFSET(HH_eventHHFunc_Parms, a), METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FUnsizedIntPropertyParams Z_Construct_UFunction_UHH_HHFunc_Statics::NewProp_ReturnValue = { "ReturnValue", nullptr, (EPropertyFlags)0x0010000000000580, UE4CodeGen_Private::EPropertyGenFlags::Int, RF_Public|RF_Transient|RF_MarkAsNative, 1, STRUCT_OFFSET(HH_eventHHFunc_Parms, ReturnValue), METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UFunction_UHH_HHFunc_Statics::PropPointers[] = {
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_UHH_HHFunc_Statics::NewProp_a,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_UHH_HHFunc_Statics::NewProp_ReturnValue,
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_UHH_HHFunc_Statics::Function_MetaDataParams[] = {
		{ "ModuleRelativePath", "HH.h" },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_UHH_HHFunc_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_UHH, nullptr, "HHFunc", nullptr, nullptr, sizeof(HH_eventHHFunc_Parms), Z_Construct_UFunction_UHH_HHFunc_Statics::PropPointers, UE_ARRAY_COUNT(Z_Construct_UFunction_UHH_HHFunc_Statics::PropPointers), RF_Public|RF_Transient|RF_MarkAsNative, (EFunctionFlags)0x04020401, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_UHH_HHFunc_Statics::Function_MetaDataParams, UE_ARRAY_COUNT(Z_Construct_UFunction_UHH_HHFunc_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_UHH_HHFunc()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_UHH_HHFunc_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UHH_NoRegister()
	{
		return UHH::StaticClass();
	}
	struct Z_Construct_UClass_UHH_Statics
	{
		static UObject* (*const DependentSingletons[])();
		static const FClassFunctionLinkInfo FuncInfo[];
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Class_MetaDataParams[];
#endif
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam NewProp_HHID_MetaData[];
#endif
		static const UE4CodeGen_Private::FUnsizedIntPropertyParams NewProp_HHID;
		static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];
		static const FCppClassTypeInfoStatic StaticCppClassTypeInfo;
		static const UE4CodeGen_Private::FClassParams ClassParams;
	};
	UObject* (*const Z_Construct_UClass_UHH_Statics::DependentSingletons[])() = {
		(UObject* (*)())Z_Construct_UClass_UObject,
		(UObject* (*)())Z_Construct_UPackage__Script_CCReflection,
	};
	const FClassFunctionLinkInfo Z_Construct_UClass_UHH_Statics::FuncInfo[] = {
		{ &Z_Construct_UFunction_UHH_HHFunc, "HHFunc" }, // 501624126
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UClass_UHH_Statics::Class_MetaDataParams[] = {
		{ "Comment", "/**\n * \n */" },
		{ "IncludePath", "HH.h" },
		{ "ModuleRelativePath", "HH.h" },
	};
#endif
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UClass_UHH_Statics::NewProp_HHID_MetaData[] = {
		{ "ModuleRelativePath", "HH.h" },
	};
#endif
	const UE4CodeGen_Private::FUnsizedIntPropertyParams Z_Construct_UClass_UHH_Statics::NewProp_HHID = { "HHID", nullptr, (EPropertyFlags)0x0010000000000000, UE4CodeGen_Private::EPropertyGenFlags::Int, RF_Public|RF_Transient|RF_MarkAsNative, 1, STRUCT_OFFSET(UHH, HHID), METADATA_PARAMS(Z_Construct_UClass_UHH_Statics::NewProp_HHID_MetaData, UE_ARRAY_COUNT(Z_Construct_UClass_UHH_Statics::NewProp_HHID_MetaData)) };
	const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UClass_UHH_Statics::PropPointers[] = {
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UClass_UHH_Statics::NewProp_HHID,
	};
	const FCppClassTypeInfoStatic Z_Construct_UClass_UHH_Statics::StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UHH>::IsAbstract,
	};
	const UE4CodeGen_Private::FClassParams Z_Construct_UClass_UHH_Statics::ClassParams = {
		&UHH::StaticClass,
		nullptr,
		&StaticCppClassTypeInfo,
		DependentSingletons,
		FuncInfo,
		Z_Construct_UClass_UHH_Statics::PropPointers,
		nullptr,
		UE_ARRAY_COUNT(DependentSingletons),
		UE_ARRAY_COUNT(FuncInfo),
		UE_ARRAY_COUNT(Z_Construct_UClass_UHH_Statics::PropPointers),
		0,
		0x001000A0u,
		METADATA_PARAMS(Z_Construct_UClass_UHH_Statics::Class_MetaDataParams, UE_ARRAY_COUNT(Z_Construct_UClass_UHH_Statics::Class_MetaDataParams))
	};
	UClass* Z_Construct_UClass_UHH()
	{
		static UClass* OuterClass = nullptr;
		if (!OuterClass)
		{
			UE4CodeGen_Private::ConstructUClass(OuterClass, Z_Construct_UClass_UHH_Statics::ClassParams);
		}
		return OuterClass;
	}
	IMPLEMENT_CLASS(UHH, 1368286490);
	template<> CCREFLECTION_API UClass* StaticClass<UHH>()
	{
		return UHH::StaticClass();
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UHH(Z_Construct_UClass_UHH, &UHH::StaticClass, TEXT("/Script/CCReflection"), TEXT("UHH"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UHH);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
#ifdef _MSC_VER
#pragma warning (pop)
#endif
```

看上去很复杂，从上往下,一步步展开宏。

首先是 `DEFINE_FUNCTION(UHH::execHHFunc)`：

```cpp
DEFINE_FUNCTION(UHH::execHHFunc)
{
    P_GET_PROPERTY(FIntProperty,Z_Param_a);
    P_FINISH;
    P_NATIVE_BEGIN;
    *(int32*)Z_Param__Result=P_THIS->HHFunc(Z_Param_a);
    P_NATIVE_END;
}
-> 
void execHHFunc( UObject* Context, FFrame& Stack, void *const Z_Param__Result) 
{
    FIntProperty::TCppType Z_Param_a = FIntProperty::GetDefaultPropertyValue();
    Stack.StepCompiledIn<FIntProperty>(&Z_Param_a);
    
    Stack.Code += !!Stack.Code;
    { 
        SCOPED_SCRIPT_NATIVE_TIMER(ScopedNativeCallTimer);
        *(int32*)Z_Param__Result = (ThisClass *) Context->HHFunc(Z_Param_a);
    }
}
```

其中 `ThisClass` 前面展开的 HH.generated.h 中已经设置为 `UHH` 的别名了。

```cpp
DEFINE_FUNCTION(UHH::execHHFunc)
{
    P_GET_PROPERTY(FIntProperty,Z_Param_a);
    P_FINISH;
    P_NATIVE_BEGIN;
    *(int32*)Z_Param__Result=P_THIS->HHFunc(Z_Param_a);
    P_NATIVE_END;
}
-> 
static void execHHFunc( UObject* Context, FFrame& Stack, void *const Z_Param__Result) 
{
    FIntProperty::TCppType Z_Param_a = FIntProperty::GetDefaultPropertyValue();
    Stack.StepCompiledIn<FIntProperty>(&Z_Param_a);
    
    Stack.Code += !!Stack.Code;
    { 
        SCOPED_SCRIPT_NATIVE_TIMER(ScopedNativeCallTimer);
        *(int32*)Z_Param__Result = (UHH *) Context->HHFunc(Z_Param_a);
    }
}
```

接下来的宏就是 `	IMPLEMENT_CLASS(UHH, 1368286490);`。

展开过程：

```cpp
IMPLEMENT_CLASS(UHH, 1368286490);

-> 

static UHHCompiledInDefer<UHH> AutoInitialize##UHH(TEXT(#UHH), sizeof(UHH), 1368286490); \
UClass* UHH::GetPrivateStaticClass() \
{ \
	static UClass* PrivateStaticClass = NULL; \
	if (!PrivateStaticClass) \
	{ \
		/* this could be handled with templates, but we want it external to avoid code bloat */ \
		GetPrivateStaticClassBody( \
			StaticPackage(), \
			(TCHAR*)TEXT(#UHH) + 1 + ((StaticClassFlags & CLASS_Deprecated) ? 11 : 0), \
			PrivateStaticClass, \
			StaticRegisterNatives##UHH, \
			sizeof(UHH), \
			alignof(UHH), \
			(EClassFlags)UHH::StaticClassFlags, \
			UHH::StaticClassCastFlags(), \
			UHH::StaticConfigName(), \
			(UClass::ClassConstructorType)InternalConstructor<UHH>, \
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<UHH>, \
			&UHH::AddReferencedObjects, \
			&UHH::Super::StaticClass, \
			&UHH::WithinClass::StaticClass \
		); \
	} \
	return PrivateStaticClass; \
}

-> 

static UHHCompiledInDefer<UHH> AutoInitializeUHH(TEXT("UHH"), sizeof(UHH), 1368286490); 
UClass* UHH::GetPrivateStaticClass() 
{ 
	static UClass* PrivateStaticClass = NULL; 
	if (!PrivateStaticClass) 
	{ 
		/* this could be handled with templates, but we want it external to avoid code bloat */ 
		GetPrivateStaticClassBody( 
			StaticPackage(), 
			(TCHAR*)TEXT("UHH") + 1 + ((StaticClassFlags & CLASS_Deprecated) ? 11 : 0), 
			PrivateStaticClass, 
			StaticRegisterNativesUHH, 
			sizeof(UHH), 
			alignof(UHH), 
			(EClassFlags)UHH::StaticClassFlags, 
			UHH::StaticClassCastFlags(), 
			UHH::StaticConfigName(), 
			(UClass::ClassConstructorType)InternalConstructor<UHH>, 
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<UHH>, 
			&UHH::AddReferencedObjects, 
			&UHH::Super::StaticClass, 
			&UHH::WithinClass::StaticClass 
		); 
	} 
	return PrivateStaticClass; 
}
```

最后剩下 `DEFINE_VTABLE_PTR_HELPER_CTOR(UHH);`

```cpp
DEFINE_VTABLE_PTR_HELPER_CTOR(UHH);
-> 
UHH::UHH(FVTableHelper& Helper) : Super(Helper) {};
```

这里Super其实就是UObject。

这样HH.gen.cpp的宏就全部展开了。

得到完整文件如下：

```cpp
#include "UObject/GeneratedCppIncludes.h"
#include "CCReflection/HH.h"
#ifdef _MSC_VER
#pragma warning (push)
#pragma warning (disable : 4883)
#endif
PRAGMA_DISABLE_DEPRECATION_WARNINGS
void EmptyLinkFunctionForGeneratedCodeHH() {}
// Cross Module References
	CCREFLECTION_API UClass* Z_Construct_UClass_UHH_NoRegister();
	CCREFLECTION_API UClass* Z_Construct_UClass_UHH();
	COREUOBJECT_API UClass* Z_Construct_UClass_UObject();
	UPackage* Z_Construct_UPackage__Script_CCReflection();
// End Cross Module References

static void execHHFunc( UObject* Context, FFrame& Stack, void *const Z_Param__Result) 
{
    FIntProperty::TCppType Z_Param_a = FIntProperty::GetDefaultPropertyValue();
    Stack.StepCompiledIn<FIntProperty>(&Z_Param_a);
    
    Stack.Code += !!Stack.Code;
    { 
        SCOPED_SCRIPT_NATIVE_TIMER(ScopedNativeCallTimer);
        *(int32*)Z_Param__Result = (UHH *) Context->HHFunc(Z_Param_a);
    }
}

void UHH::StaticRegisterNativesUHH()
{
	UClass* Class = UHH::StaticClass();
	static const FNameNativePtrPair Funcs[] = {
		{ "HHFunc", &UHH::execHHFunc },
	};
	FNativeFunctionRegistrar::RegisterFunctions(Class, Funcs, UE_ARRAY_COUNT(Funcs));
}
struct Z_Construct_UFunction_UHH_HHFunc_Statics
{
	struct HH_eventHHFunc_Parms
	{
		int32 a;
		int32 ReturnValue;
	};
	static const UE4CodeGen_Private::FUnsizedIntPropertyParams NewProp_a;
	static const UE4CodeGen_Private::FUnsizedIntPropertyParams NewProp_ReturnValue;
	static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];
#if WITH_METADATA
	static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
	static const UE4CodeGen_Private::FFunctionParams FuncParams;
};
const UE4CodeGen_Private::FUnsizedIntPropertyParams Z_Construct_UFunction_UHH_HHFunc_Statics::NewProp_a = { "a", nullptr, (EPropertyFlags)0x0010000000000080, UE4CodeGen_Private::EPropertyGenFlags::Int, RF_Public|RF_Transient|RF_MarkAsNative, 1, STRUCT_OFFSET(HH_eventHHFunc_Parms, a), METADATA_PARAMS(nullptr, 0) };
const UE4CodeGen_Private::FUnsizedIntPropertyParams Z_Construct_UFunction_UHH_HHFunc_Statics::NewProp_ReturnValue = { "ReturnValue", nullptr, (EPropertyFlags)0x0010000000000580, UE4CodeGen_Private::EPropertyGenFlags::Int, RF_Public|RF_Transient|RF_MarkAsNative, 1, STRUCT_OFFSET(HH_eventHHFunc_Parms, ReturnValue), METADATA_PARAMS(nullptr, 0) };
const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UFunction_UHH_HHFunc_Statics::PropPointers[] = {
	(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_UHH_HHFunc_Statics::NewProp_a,
	(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_UHH_HHFunc_Statics::NewProp_ReturnValue,
};
#if WITH_METADATA
const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_UHH_HHFunc_Statics::Function_MetaDataParams[] = {
	{ "ModuleRelativePath", "HH.h" },
};
#endif
const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_UHH_HHFunc_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_UHH, nullptr, "HHFunc", nullptr, nullptr, sizeof(HH_eventHHFunc_Parms), Z_Construct_UFunction_UHH_HHFunc_Statics::PropPointers, UE_ARRAY_COUNT(Z_Construct_UFunction_UHH_HHFunc_Statics::PropPointers), RF_Public|RF_Transient|RF_MarkAsNative, (EFunctionFlags)0x04020401, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_UHH_HHFunc_Statics::Function_MetaDataParams, UE_ARRAY_COUNT(Z_Construct_UFunction_UHH_HHFunc_Statics::Function_MetaDataParams)) };
UFunction* Z_Construct_UFunction_UHH_HHFunc()
{
	static UFunction* ReturnFunction = nullptr;
	if (!ReturnFunction)
	{
		UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_UHH_HHFunc_Statics::FuncParams);
	}
	return ReturnFunction;
}
UClass* Z_Construct_UClass_UHH_NoRegister()
{
	return UHH::StaticClass();
}
struct Z_Construct_UClass_UHH_Statics
{
	static UObject* (*const DependentSingletons[])();
	static const FClassFunctionLinkInfo FuncInfo[];
#if WITH_METADATA
	static const UE4CodeGen_Private::FMetaDataPairParam Class_MetaDataParams[];
#endif
#if WITH_METADATA
	static const UE4CodeGen_Private::FMetaDataPairParam NewProp_HHID_MetaData[];
#endif
	static const UE4CodeGen_Private::FUnsizedIntPropertyParams NewProp_HHID;
	static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];
	static const FCppClassTypeInfoStatic StaticCppClassTypeInfo;
	static const UE4CodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UHH_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UObject,
	(UObject* (*)())Z_Construct_UPackage__Script_CCReflection,
};
const FClassFunctionLinkInfo Z_Construct_UClass_UHH_Statics::FuncInfo[] = {
	{ &Z_Construct_UFunction_UHH_HHFunc, "HHFunc" }, // 501624126
};
#if WITH_METADATA
const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UClass_UHH_Statics::Class_MetaDataParams[] = {
	{ "Comment", "/**\n * \n */" },
	{ "IncludePath", "HH.h" },
	{ "ModuleRelativePath", "HH.h" },
};
#endif
#if WITH_METADATA
const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UClass_UHH_Statics::NewProp_HHID_MetaData[] = {
	{ "ModuleRelativePath", "HH.h" },
};
#endif
const UE4CodeGen_Private::FUnsizedIntPropertyParams Z_Construct_UClass_UHH_Statics::NewProp_HHID = { "HHID", nullptr, (EPropertyFlags)0x0010000000000000, UE4CodeGen_Private::EPropertyGenFlags::Int, RF_Public|RF_Transient|RF_MarkAsNative, 1, STRUCT_OFFSET(UHH, HHID), METADATA_PARAMS(Z_Construct_UClass_UHH_Statics::NewProp_HHID_MetaData, UE_ARRAY_COUNT(Z_Construct_UClass_UHH_Statics::NewProp_HHID_MetaData)) };
const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UClass_UHH_Statics::PropPointers[] = {
	(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UClass_UHH_Statics::NewProp_HHID,
};
const FCppClassTypeInfoStatic Z_Construct_UClass_UHH_Statics::StaticCppClassTypeInfo = {
	TCppClassTypeTraits<UHH>::IsAbstract,
};
const UE4CodeGen_Private::FClassParams Z_Construct_UClass_UHH_Statics::ClassParams = {
	&UHH::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	FuncInfo,
	Z_Construct_UClass_UHH_Statics::PropPointers,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	UE_ARRAY_COUNT(FuncInfo),
	UE_ARRAY_COUNT(Z_Construct_UClass_UHH_Statics::PropPointers),
	0,
	0x001000A0u,
	METADATA_PARAMS(Z_Construct_UClass_UHH_Statics::Class_MetaDataParams, UE_ARRAY_COUNT(Z_Construct_UClass_UHH_Statics::Class_MetaDataParams))
};
UClass* Z_Construct_UClass_UHH()
{
	static UClass* OuterClass = nullptr;
	if (!OuterClass)
	{
		UE4CodeGen_Private::ConstructUClass(OuterClass, Z_Construct_UClass_UHH_Statics::ClassParams);
	}
	return OuterClass;
}

static UHHCompiledInDefer<UHH> AutoInitializeUHH(TEXT("UHH"), sizeof(UHH), 1368286490); 
UClass* UHH::GetPrivateStaticClass() 
{ 
	static UClass* PrivateStaticClass = NULL; 
	if (!PrivateStaticClass) 
	{ 
		/* this could be handled with templates, but we want it external to avoid code bloat */ 
		GetPrivateStaticClassBody( 
			StaticPackage(), 
			(TCHAR*)TEXT("UHH") + 1 + ((StaticClassFlags & CLASS_Deprecated) ? 11 : 0), 
			PrivateStaticClass, 
			StaticRegisterNativesUHH, 
			sizeof(UHH), 
			alignof(UHH), 
			(EClassFlags)UHH::StaticClassFlags, 
			UHH::StaticClassCastFlags(), 
			UHH::StaticConfigName(), 
			(UClass::ClassConstructorType)InternalConstructor<UHH>, 
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<UHH>, 
			&UHH::AddReferencedObjects, 
			&UHH::Super::StaticClass, 
			&UHH::WithinClass::StaticClass 
		); 
	} 
	return PrivateStaticClass; 
}

template<> CCREFLECTION_API UClass* StaticClass<UHH>()
{
	return UHH::StaticClass();
}
static FCompiledInDefer Z_CompiledInDefer_UClass_UHH(Z_Construct_UClass_UHH, &UHH::StaticClass, TEXT("/Script/CCReflection"), TEXT("UHH"), false, nullptr, nullptr, nullptr);

UHH::UHH(FVTableHelper& Helper) : Super(Helper) {};

PRAGMA_ENABLE_DEPRECATION_WARNINGS
#ifdef _MSC_VER
#pragma warning (pop)
#endif
```

可能会有漏的，但是重要的部分应该是不会错的。

这样生成文件就全部展开完了。