---
layout:     post
title:      读取动态库符号表以及指令地址转化
subtitle:   你快乐吗
date:       2020-02-07
author:     bbkgl
header-img: img/post-bg-0013.jpg
catalog: true
tags:
    - leetcode
---

>为众人抱薪者
>
>已冻毙于风雪

## 获取可执行文件的符号表

获取可执行文件的符号表其实还是比较简单的，直接用libelfin的接口读取就行了，当然也可以用libelf库，也不是很难，这里我都会演示一下的，并和readelf读取的进行对比。

#### 使用libelfin读取符号表

libelfin的接口设计很人性化，为什么这么说呢？两个原因。

- 现代C++11写的，比较简洁，不会各种指针到处飞
- 门槛低，不需要了解太多关于elf/dwarf符号的的知识应该就能用

等会看看用libelf库实现同样的功能多麻烦，就发现libelfin的好了。

首先可以遍历elf文件中的各个段：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>
#include <elf/elf++.hh>
#include <string>
#include <fcntl.h>
#include <unistd.h>

int main() {
    std::string fname = "/home/bbkgl/vimcode/server";
    int fd = open(fname.c_str(), O_RDONLY);
    elf::elf ef(elf::create_mmap_loader(fd));
    for (const auto &sec : ef.sections()) { 
        printf("Symbol table '%s':\n", sec.get_name().c_str());
    }
    close(fd);
    return 0;
}
```

看一下输出：

![20200207213051.png](https://raw.githubusercontent.com/bbkglpic/picpic/master/img/20200207213051.png)

可以看到程序的各个段，也有我们熟知的`text`、`data`、`bss`段，也有我们后面要用的符号段：`.symtab`、`.dynamic`，也就是符号表。

所以得从这两个section中读取符号，同样使用libelfin库，接着上面的程序写。

稍微加上几行就好了，但是注意这里我进行了筛选，得到只有函数的符号，并使用重载的`elf::to_string()`去打印符号类型，筛选后应该都是`func`。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>
#include <elf/elf++.hh>
#include <string>
#include <unistd.h>
#include <fcntl.h>

int main() {
    std::string fname = "/home/bbkgl/vimcode/server";
    int fd = open(fname.c_str(), O_RDONLY);
    elf::elf ef(elf::create_mmap_loader(fd));
    for (const auto &sec : ef.sections()) {
        if (sec.get_hdr().type != elf::sht::symtab && sec.get_hdr().type != elf::sht::dynsym)
            continue;
        for (const auto &sym : sec.as_symtab()) {
            auto &data = sym.get_data();
            if (data.type() != elf::stt::func) continue;
            printf("%016lx %8ld %10s %s\n", data.value, data.size,
                   elf::to_string(data.type()).c_str(), sym.get_name().c_str());
        }
    }
    close(fd);
    return 0;
}
```

看到输出结果：

![20200207230414.png](https://raw.githubusercontent.com/bbkglpic/picpic/master/img/20200207230414.png)

可以看到所有函数符号都打印出来了，还打印了函数的起始指令地址和函数的指令在函数中所有指令地址上的范围，这里可以说明一下，直接看汇编会更清楚一点，这里以_start函数举例。

使用`objdump -d server > server.txt`拿到汇编指令，然后打开`server.txt`，找到_start函数的指令。

![20200207232645.png](https://raw.githubusercontent.com/bbkglpic/picpic/master/img/20200207232645.png)

在之前图中可以看到，_start函数的起始指令地址为`0x0000000000400bb0`，地址范围大小为42，`0x400bb0 + 42 = 0x400bda`，正好就是最后一条指令，所以打印的符号表中的意义就很明了了。

当然也会发现有很多函数的起始指令地址是0，地址范围大小也是0，说明这些函数是动态库中导入的，后面会详细说如何获取这部分函数的符号表。

#### 使用libelf库读取符号表

其实原理和步骤其实是一样的，只是用libelf库相对来说会复杂很多。

然后我就直接贴代码了，注意的是libelf会依赖于libz：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>
#include <elf/elf++.hh>
#include <string>
#include <fcntl.h>
#include <libelf.h>
#include <unistd.h>
#include <gelf.h>

int main() {
    std::string fname = "/home/bbkgl/vimcode/server";
    int fd = open(fname.c_str(), O_RDONLY);
    // Before the first call to elf_begin() , a program must call elf_version() to coordinate versions.
    if (elf_version(EV_CURRENT) == EV_NONE) {
        printf("EV_NONE");
    }

    Elf *elf = elf_begin(fd, ELF_C_READ_MMAP, nullptr);
    if (elf != nullptr) {
        /* 确定是文件类型是否是ELF文件 */
        if (elf_kind (elf) == ELF_K_ELF) {
            printf("elf exe\n");
        } else if (elf_kind (elf) == ELF_K_AR) { /* 目标是库文件 */
            printf("lib\n");
        }
        Elf_Scn     *scn = nullptr;
        GElf_Shdr   shdr;
        Elf_Data    *data;
        int         ii, count;
        while ((scn = elf_nextscn(elf, scn)) != nullptr) {
            gelf_getshdr(scn, &shdr);
            if (shdr.sh_type == SHT_SYMTAB || shdr.sh_type == SHT_DYNSYM) {
                data = elf_getdata(scn, nullptr);
                count = shdr.sh_size / shdr.sh_entsize;
                // sym.st_info == 18的时候是func类型
                for (ii = 0; ii < count; ++ii) {
                    GElf_Sym sym;
                    gelf_getsym(data, ii, &sym);
                    // 只打印函数符号表
                    if (ELF32_ST_TYPE(sym.st_info) != STT_FUNC) continue;
                    char *name = nullptr;
                    int status = 99;
                    printf("%016lx %4d %s\n", sym.st_value, sym.st_size, elf_strptr(elf, shdr.sh_link, sym.st_name));
                }
            }
        }
        /* 关闭elf结构句柄 */
        elf_end (elf);
    }
    close(fd);
    return 0;
}
```

下面是输出结果，其实和之前libelfin差不多：

![20200207235325.png](https://raw.githubusercontent.com/bbkglpic/picpic/master/img/20200207235325.png)

## 获取可执行文件引入的动态库的符号表

