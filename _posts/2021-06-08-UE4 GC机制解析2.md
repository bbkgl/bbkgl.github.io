---
clayout:     post
typora-root-url: ..
title:      UE4 GC机制解析（二）
subtitle:   收集对象，构造有向图
date:       2021-06-08
author:     bbkgl
header-img: img/post-bg-0024.jpg
catalog: true
tags:
    - UE4
    - C++
---

> 微微风簇浪
>
> 散作满河星

标记-清除的GC机制要包括以下四个流程。



![image-20210609115045747](/cloud_img/image-20210609115045747.png)

接下来介绍UE4中的信息收集过程。

## 引擎加载流程中收集信息

由于内存信息，包括类型信息在编译期就已经确定，所以在反射支持的情况下，便能够在初始化的时候进行收集。之前介绍反射时，有讲到引擎加载的流程中会调用 `ProcessNewlyLoadedUObjects()` 函数（多次）。

![image-20210609145043966](/cloud_img/image-20210609145043966.png)

而 `ProcessNewlyLoadedUObjects()` 函数中会调用  `UClass::AssembleReferenceTokenStreams()` ，后者是一个静态函数，直接通过类名调用，代码也很简短：

```cpp
void UClass::AssembleReferenceTokenStreams()
{
	SCOPED_BOOT_TIMING("AssembleReferenceTokenStreams (can be optimized)");
	// Iterate over all class objects and force the default objects to be created. Additionally also
	// assembles the token reference stream at this point. This is required for class objects that are
	// not taken into account for garbage collection but have instances that are.
	for (FRawObjectIterator It(false); It; ++It) // GetDefaultObject can create a new class, that need to be handled as well, so we cannot use TObjectIterator
	{
		if (UClass* Class = Cast<UClass>((UObject*)(It->Object)))
		{
			// Force the default object to be created (except when we're in the middle of exit purge -
			// this may happen if we exited PreInit early because of error).
			// 
			// Keep from handling script generated classes here, as those systems handle CDO 
			// instantiation themselves.
			if (!GExitPurge && !Class->HasAnyFlags(RF_BeingRegenerated))
			{
				Class->GetDefaultObject(); // Force the default object to be constructed if it isn't already
			}
			// Assemble reference token stream for garbage collection/ RTGC.
			if (!Class->HasAnyFlags(RF_ClassDefaultObject) && !Class->HasAnyClassFlags(CLASS_TokenStreamAssembled))
			{
				Class->AssembleReferenceTokenStream();
			}
		}
	}
}
```

函数的执行流程如下：

1. 遍历所有的UClass（每一个用 `UCLASS()` 宏修饰的类都会生成一个UClass对象）
2. 对每个UClass生成一个默认的对象（指被UClass修饰的类的对象）
3. 对每个UClass，如果没有收集gc的token stream信息，则调用每个UClass对象的 `AssembleReferenceTokenStream()` 函数（非静态）

所以继续进入 `AssembleReferenceTokenStream()` 函数（非静态）。

```cpp
void UClass::AssembleReferenceTokenStream(bool bForce)
{
	// Lock for non-native classes
	FScopeLockIfNotNative ReferenceTokenStreamLock(ReferenceTokenStreamCritical, !(ClassFlags & CLASS_Native));

	UE_CLOG(!IsInGameThread() && !IsGarbageCollectionLocked(), LogGarbage, Fatal, TEXT("AssembleReferenceTokenStream for %s called on a non-game thread while GC is not locked."), *GetFullName());

	if (!HasAnyClassFlags(CLASS_TokenStreamAssembled) || bForce)
	{
		if (bForce)
		{
			ReferenceTokenStream.Empty();
			ClassFlags &= ~CLASS_TokenStreamAssembled;
		}
		TArray<const FStructProperty*> EncounteredStructProps;

		// Iterate over properties defined in this class
		for( TFieldIterator<FProperty> It(this,EFieldIteratorFlags::ExcludeSuper); It; ++It)
		{
			FProperty* Property = *It;
			Property->EmitReferenceInfo(*this, 0, EncounteredStructProps);
		}

		if (UClass* SuperClass = GetSuperClass())
		{
			// We also need to lock the super class stream in case something (like PostLoad) wants to reconstruct it on GameThread
			FScopeLockIfNotNative SuperClassReferenceTokenStreamLock(SuperClass->ReferenceTokenStreamCritical, !(SuperClass->ClassFlags & CLASS_Native));
			
			// Make sure super class has valid token stream.
			SuperClass->AssembleReferenceTokenStream();
			if (!SuperClass->ReferenceTokenStream.IsEmpty())
			{
				// Prepend super's stream. This automatically handles removing the EOS token.
				ReferenceTokenStream.PrependStream(SuperClass->ReferenceTokenStream);
			}
		}
		else
		{
			UObjectBase::EmitBaseReferences(this);
		}

		{
			check(ClassAddReferencedObjects != NULL);
			const bool bKeepOuter = true;//GetFName() != NAME_Package;
			const bool bKeepClass = true;//!HasAnyInternalFlags(EInternalObjectFlags::Native) || IsA(UDynamicClass::StaticClass());

			ClassAddReferencedObjectsType AddReferencedObjectsFn = nullptr;
#if !WITH_EDITOR
			// In no-editor builds UObject::ARO is empty, thus only classes
			// which implement their own ARO function need to have the ARO token generated.
			if (ClassAddReferencedObjects != &UObject::AddReferencedObjects)
			{
				AddReferencedObjectsFn = ClassAddReferencedObjects;
			}
#else
			AddReferencedObjectsFn = ClassAddReferencedObjects;
#endif
			ReferenceTokenStream.Fixup(AddReferencedObjectsFn, bKeepOuter, bKeepClass);
		}

		if (ReferenceTokenStream.IsEmpty())
		{
			return;
		}

		// Emit end of stream token.
		static const FName EOSDebugName("EndOfStreamToken");
		EmitObjectReference(0, EOSDebugName, GCRT_EndOfStream);

		// Shrink reference token stream to proper size.
		ReferenceTokenStream.Shrink();

		check(!HasAnyClassFlags(CLASS_TokenStreamAssembled)); // recursion here is probably bad
		ClassFlags |= CLASS_TokenStreamAssembled;
	}
}
```

代码有点长，但总结一下，就是为每个被UClass修饰的类，生成对应的token stream，用于描述GC信息。同时通过 `CLASS_TokenStreamAssembled` 标记防止重复生成token stream。

较为详细的流程如下：

1. 首先加上锁，防止另外一个线程同时进入该函数执行一样的流程，造成内存读写冲突
2. 遍历UClass中的每个Property，调用每个Property的 `EmitReferenceInfo()` 方法，会将UClass对象的指针传入，主要是为了后续再次调用UClass的 `EmitObjectReference()` 方法，将每个Property的内存偏移信息、类型信息传回，并存入到每个UClass对象的 `ReferenceTokenStream` 成员中。需要说明的是，不同类型的Property的 `EmitReferenceInfo()` 方法都被覆盖/重写（override）了，也就是说每个Property类都有自己的 `EmitReferenceInfo()` 方法。
3. 如果这个类有父类，则会递归地调用`AssembleReferenceTokenStream()` 方法，收集父类的上述信息到 `ReferenceTokenStream` 中，同时将父类的 token stream 添加到自己的 token stream 之前；该步骤会一直持续到 `UObjectBase` 类，因为这个类没有父类。
4. 最后完成收集会将 `ClassFlags` 添加上 `CLASS_TokenStreamAssembled` 标志，表示该类的token stream信息已经收集完毕。

看到这里的时候我脑子里出现了三个疑问：

1. 如果是一直递归收集父类的内存偏移信息直到 `UObjectBase`类，那必然有很多重复收集的信息，很简单的例子就是类 `UObject` 作为整个对象系统的基类，不是会被重复收集很多次吗？
2. 为什么需要把父类成员的token stream添加到子类之前呢？
3. 在内存中，类成员的偏移信息是如何记录的（字节对齐）？

首先第一个问题，每个**类的token stream是不会被重复记录**的。经过继承后，各个类之间的关系，有点类似于一棵多叉树。

而递归调用 `AssembleReferenceTokenStream()` 函数（非静态）的过程，就是从多叉树的某个叶子结点，向整棵树的根结点回溯。每到达一个新结点，首先就会检查是否该结点是否已经被遍历过了，也就是看每`UClass::ClassFlags & CLASS_TokenStreamAssembled` 是不是为1，即遍历过就会直接返回，而对每个结点/每个 `UClass` 处理的过程是加锁的。所以每个结点都不会被重复遍历，也就是每个类的 token stream 是不会被重复记录的。

2、3问题与C++对象内存模型和字节对齐有关，以下介绍。

## 类成员内存信息收集

#### token stream与内存偏移

很好奇token stream是如何将内存偏移信息以及类型信息编码到一个int32的。

看了源码和相关的知识以后，结果还是比我想象中的要简单的，也发现 UE4 将 `UProperty` 替换成了 `FProperty`。

 `FProperty` 没有再从 `UObject` 继承，而是继承自 `FField`， `FField` 也没有继承自 `UObject`。

![image-20210708205337443](/cloud_img/image-20210708205337443.png)

![image-20210708205347083](/cloud_img/image-20210708205347083.png)

从函数 `EmitReferenceInfo()` 开始看，首先发现 `FProperty::EmitReferenceInfo()` 是一个空的函数。

![image-20210708204015368](/cloud_img/image-20210708204015368.png)

实际上不同类型的的 `EmitReferenceInfo()` 是各自实现的：

![image-20210708204116060](/cloud_img/image-20210708204116060.png)

我看了部分类型的实现，发现基本都是将偏移量以及各自成员的名字传回，这里以 `FStructProperty::EmitReferenceInfo()` 为例。

```cpp
void FStructProperty::EmitReferenceInfo(UClass& OwnerClass, int32 BaseOffset, TArray<const FStructProperty*>& EncounteredStructProps)
{
	check(Struct);
	if (Struct->StructFlags & STRUCT_AddStructReferencedObjects)
	{
		UScriptStruct::ICppStructOps* CppStructOps = Struct->GetCppStructOps();
		check(CppStructOps); // else should not have STRUCT_AddStructReferencedObjects
		FGCReferenceFixedArrayTokenHelper FixedArrayHelper(OwnerClass, BaseOffset + GetOffset_ForGC(), ArrayDim, ElementSize, *this);

		OwnerClass.EmitObjectReference(BaseOffset + GetOffset_ForGC(), GetFName(), GCRT_AddStructReferencedObjects);

		void *FunctionPtr = (void*)CppStructOps->AddStructReferencedObjects();
		OwnerClass.ReferenceTokenStream.EmitPointer(FunctionPtr);
	}
	if (ContainsObjectReference(EncounteredStructProps, EPropertyObjectReferenceType::Strong | EPropertyObjectReferenceType::Weak))
	{
		FGCReferenceFixedArrayTokenHelper FixedArrayHelper(OwnerClass, BaseOffset + GetOffset_ForGC(), ArrayDim, ElementSize, *this);

		FProperty* Property = Struct->PropertyLink;
		while( Property )
		{
			Property->EmitReferenceInfo(OwnerClass, BaseOffset + GetOffset_ForGC(), EncounteredStructProps);
			Property = Property->PropertyLinkNext;
		}
	}
}
```

名字是在反射信息收集阶段的时候，通过生成文件写入的。

那内存偏移量呢？ 这里调用了一个函数是 `GetOffset_ForGC()`。

```cpp
/** Return offset of property from container base. */
	FORCEINLINE int32 GetOffset_ForGC() const
	{
		return Offset_Internal;
	}
```

实际也只是返回了一个成员变量而已，也就是说偏移量在对应的 `FProperty` 对象生成的时候就就已经决定好了。

#### 对象模型与token stream记录

