---
clayout:     post
typora-root-url: ..
title:      UE4 GC机制解析（三）：标记与清除
subtitle:   GC锁、可达性分析
date:       2021-08-03
author:     bbkgl
header-img: img/post-bg-0025.jpg
catalog: true
tags:
    - UE4
    - C++
---

> 故乡云水地
>
> 归梦不宜秋

继续接上文，分析UE GC的mark和sweep。

## 可达性分析

通过调用 `FRealTimeGC::PerformReachabilityAnalysis()` 实现对所有 UObject 的可达性分析。

```cpp
	void PerformReachabilityAnalysis(EObjectFlags KeepFlags, bool bForceSingleThreaded, bool bWithClusters)
	{
		/** Growing array of objects that require serialization */
		FGCArrayStruct* ArrayStruct = FGCArrayPool::Get().GetArrayStructFromPool();
		TArray<UObject*>& ObjectsToSerialize = ArrayStruct->ObjectsToSerialize;

		// Reset object count.
		GObjectCountDuringLastMarkPhase.Reset();

		// Make sure GC referencer object is checked for references to other objects even if it resides in permanent object pool
		if (FPlatformProperties::RequiresCookedData() && FGCObject::GGCObjectReferencer && GUObjectArray.IsDisregardForGC(FGCObject::GGCObjectReferencer))
		{
			ObjectsToSerialize.Add(FGCObject::GGCObjectReferencer);
		}

		{
			const double StartTime = FPlatformTime::Seconds();
			(this->*MarkObjectsFunctions[GetGCFunctionIndex(!bForceSingleThreaded, bWithClusters)])(ObjectsToSerialize, KeepFlags);
			UE_LOG(LogGarbage, Verbose, TEXT("%f ms for MarkObjectsAsUnreachable Phase (%d Objects To Serialize)"), (FPlatformTime::Seconds() - StartTime) * 1000, ObjectsToSerialize.Num());
		}

		{
			const double StartTime = FPlatformTime::Seconds();
			PerformReachabilityAnalysisOnObjects(ArrayStruct, bForceSingleThreaded, bWithClusters);
			UE_LOG(LogGarbage, Verbose, TEXT("%f ms for Reachability Analysis"), (FPlatformTime::Seconds() - StartTime) * 1000);
		}
        
		// Allowing external systems to add object roots. This can't be done through AddReferencedObjects
		// because it may require tracing objects (via FGarbageCollectionTracer) multiple times
		FCoreUObjectDelegates::TraceExternalRootsForReachabilityAnalysis.Broadcast(*this, KeepFlags, bForceSingleThreaded);

		FGCArrayPool::Get().ReturnToPool(ArrayStruct);

#if UE_BUILD_DEBUG
		FGCArrayPool::Get().CheckLeaks();
#endif
	}

```

注意到定义了一个 `FGCArrayStruct` 类型的局部变量 `ArrayStruct`，用于存储需要序列化的 UObject。这个变量通过 `FGCArrayPool::GetArrayStructFromPool()` 返回，在 `MarkObjectsAsUnreachable()` 也可以见到这样的用法。 `ArrayStruct->ObjectsToSerialize` 是一个长度持续增长的序列，在整个可达性分析的过程中存储所有可达的UObject指针。我感觉是通过存在这样的一个序列池，内存连续，用于在可达性分析阶段存储 `UObject` 指针，以减小cache miss。

首先将 `FGCObject::GGCObjectReferencer` 加入到了 `ObjectsToSerialize` 中， `FGCObject::GGCObjectReferencer` 是类 `FGCObject`  中的一个静态成员，其充当了一座联系  `FGCObject` 和 `UObject` 的桥梁，可以让继承于  `FGCObject` 的对象，通过调用 `AddReferencedObjects()` 将自己纳入到可达性分析中。其实就是可以让   `FGCObject` 子类的一些 `UObject` 成员可以被可达性分析判定为可达，防止成员中的 `UObject` 被清理掉，所以会看到类 `GGCObjectReferencer` 中有一个 `TArray<FGCObject *>` 的成员，用于可达性分析中遍历每个 `FGCObject` 对象。这件事虽然说起来简单，但UE中实现却相当复杂。

后面两处代码块中，一处会遍历所有的 `UObject`，试图将它们都标记为不可达，明确可达或者特殊的UObject的放入到 `ObjectsToSerialize` 中，所以可以看到传的是引用。

另外一处就是可达性分析，可达性分析中会逐渐将所有可达的 `UObject` 添加到 `ArrayStruct->ObjectsToSerialize` 中，不可达的则标记不可达。

#### MarkObjectsAsUnreachable

 `FRealTimeGC::PerformReachabilityAnalysis()` 中调用的是 `*MarkObjectsFunctions[index]`，这里得到的是一个函数指针。

```cpp
/** Default constructor, initializing all members. */
FRealtimeGC()
{
    MarkObjectsFunctions[GetGCFunctionIndex(false, false)] = &FRealtimeGC::MarkObjectsAsUnreachable<false, false>;
    MarkObjectsFunctions[GetGCFunctionIndex(true, false)] = &FRealtimeGC::MarkObjectsAsUnreachable<true, false>;
    MarkObjectsFunctions[GetGCFunctionIndex(false, true)] = &FRealtimeGC::MarkObjectsAsUnreachable<false, true>;
    MarkObjectsFunctions[GetGCFunctionIndex(true, true)] = &FRealtimeGC::MarkObjectsAsUnreachable<true, true>;
    ...
}

```

通过对非类型参数的函数模板 `MarkObjectsAsUnreachable` 实例化得到具体函数的指针，将函数指针的地址存储到 `MarkObjectsFunctions` 数组中，就得到了四种情况下的 `MarkObjectsAsUnreachable()` 函数，也就是 是否多线程和是否使用Cluster的组合。

```cpp
template <bool bParallel, bool bWithClusters>
void MarkObjectsAsUnreachable(TArray<UObject*>& ObjectsToSerialize, const EObjectFlags KeepFlags)
{
    ...
}
```

函数内部代码比较长，就不放代码一行一行分析了，介绍下重要流程。

函数功能：按照既定规则，将 `UObject` 加入到 `ObjectsToSerializeArrays` 中或者标记为 `Unreachable` 不可达，也就是认为可达的 `UObject` 都添加到了 `ObjectsToSerializeArrays` 中。

认为可达的 `UObject` 符合以下条件之一：

- 属于 root set
- 包含 `EInternalObjectFlags::GarbageCollectionKeepFlags` 
- 不在 pending kill 状态，且包含 `KeepFlags`，且 `KeepFlags != 0`

当然除此之外还有Cluster的处理，这不是重点。过程使用了 UE 的多线程框架并行处理和标记，详见 `ParallelFor`。

最终在可达性分析之前得到了部分可达对象序列 `ObjectsToSerializeArrays`。

#### PerformReachabilityAnalysisOnObjects

实际调用链条为：

![image-20210804164238100](/cloud_img/image-20210804164238100.png)

也是根据是否使用多线程来决定调用路径的，如果是多线程就会用到类 `TFastReferenceCollector::FCollectorTaskQueue` 的多线程并行机制。

![image-20210804172015033](/cloud_img/image-20210804172015033.png)

不过最终都会调用到 `TFastReferenceCollector::ProcessObjectArray()` 这个函数，多线程则是将 可达的`UObject` 序列分到不同的线程执行可达性分析。这种情况下，性能就取决于最慢的那个线程了。当然还有个问题，就是线程同步的成本会不会也相当大呢？暂时挖坑，以后分析UE的多线程相关的实现。

以下分析 `ProcessObjectArray()` 的实现，这个函数的实现并不在 GarbageCollection.cpp 中，而是在 FastReferenceCollection.h 中。

简单描述该函数的功能：通过遍历ObjectsToSerialize，进行广度搜索（部分类型会深度有限搜索），将可达的UObject指针不断添加到ObjectsToSerialize中，直到ObjectsToSerialize中所有的UObject都被访问过。这样就将可达的UObject对象全部收集好了，未收集的即为不可达。

看到定义了一个`Stack`时，我以为会使用栈模拟递归深搜来收集UObject，但实际上只有部分类型才会模拟递归，否则的话就直接加入到NewObjectsToSerialize中，像是广度优先搜索和深度优先搜索结合。

![image-20210805151810249](/cloud_img/image-20210805151810249.png)

其中遍历完当前的 `ObjectsToSerialize` 后，一轮遍历就完成了。顺利的话，就会将 `NewObjectsToSerialize` 和 `ObjectsToSerialize` 进行交换，下一轮中就会遍历 “原NewObjectsToSerialize”，往 “原ObjectsToSerialize” 中添加元素。

而如果 `NewObjectsToSerialize` 数量大于一个Task可以处理的数量，就会将 `NewObjectsToSerialize` 再次分给1到多个线程去遍历。

![image-20210805155047571](/cloud_img/image-20210805155047571.png)

对于每个UObject，会遍历其对应的 `TokenStream` ，也就是 [GC信息收集](https://bbkgl.github.io/2021/06/08/UE4-GC%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%901/) 中介绍的引用收集得到的序列。然后通过偏移量访问到每个UObject的子UObject，判断其类型。类型处理主要分为三种：

- 一种就是普通的UObject，这种情况下就直接将子UObject添加到 `NewObjectsToSerialize` 中，不继续递归处理，同时为其添加到引用。
- 第二种就是ArrayStruct类型，这种情况下会递归扫描序列中的UObject。
- 还有就是需要调用 `AddReferencedObjects` 添加引用的，这个在前面提到过

array/struct类型的处理，也可以在函数前面部分的for循环看到。

![image-20210805160132763](/cloud_img/image-20210805160132763.png)

最终每个可达的UObject都会在函数 `HandleObjectReference()` 中处理，清除掉不可达标记，如果是多线程，则需要通过原子操作判断是否已经清除过，过程不再赘述。

![image-20210805172745227](/cloud_img/image-20210805172745227.png)

这里还有个疑问，被 `UPROPERTY` 修饰的成员，如果被 GC 回收了，如何将对应的指针置空的呢？

很容易想到，既然可达性分析的时候会遍历所有引用，也就是能拿到每个成员的偏移量和实际的虚拟内存地址，这样情况下，将对应的地址上8（64bit）字节的内容直接置为0就可以了。当然这种方法相当暴力，UE4是直接传了一个指针的引用，这样的话就能修改指针的指向了，具体的实现在 `HandleObjectReference()` 中，可以看到参数Object是个指针类型的引用，自然可以修改指针的指向，其实就是修改指针记录的地址。

```cpp
FORCEINLINE void HandleObjectReference(TArray<UObject*>& ObjectsToSerialize, const UObject * const ReferencingObject, UObject*& Object, const bool bAllowReferenceElimination)
{
    ...
    const int32 ObjectIndex = GUObjectArray.ObjectToIndex(Object);
    FUObjectItem* ObjectItem = GUObjectArray.IndexToObjectUnsafeForGC(ObjectIndex);
    // Remove references to pending kill objects if we're allowed to do so.
    if (ObjectItem->IsPendingKill() && bAllowReferenceElimination)
    {
        //checkSlow(ObjectItem->HasAnyFlags(EInternalObjectFlags::ClusterRoot) == false);
        checkSlow(ObjectItem->GetOwnerIndex() <= 0)

            // Null out reference.
            Object = NULL;
    }

```

#### 收集不可达对象

收集不可达对象的操作在函数 `GatherUnreachableObjects` 中执行。里面有Cluster的解组操作，但这篇文章不对这个展开讲。

函数的主要功能：（并行）遍历 `GUObjectArray` ，将所有标记为不可达的UObject加入到 `GUnreachableObjects` 中。

从源码中看出来，这个过程是直接访问的 `GUObjectArray` ，这样确实需要加锁，GameThread必须等待这个过程完成，否则可能会访问冲突。不过我在想，如果在前面过程中将所有标记不可达的时候就复制一份，因为全部是指针，直接memcopy。这样后续清理包括这个收集过程不就不需要再去访问这个 `GUObjectArray` 了吗，然后再分帧一同清理掉。进一步可以做成双Buffer，这样就每次swap一下就行。

## 不可达对象清理

从我卑微又弱小的角度来看，清理过程应该就是几行代码：

```cpp
for (auto &objectPtr : unreachableList) {
    delete objectPtr;
}
```

再不济，要从表里或者序列里删除，也就是加个 erase。

但是UE里的实现却相当复杂，我想至少应该考虑以下几个方面：

- 分帧清理
- 多线程加速
- Cluster（簇）
- 清理`UObjectHashTables` 等全局的UObject表以及其他引用
- 
