---
clayout:     post
typora-root-url: ..
title:      UE4 GC机制解析（三）：标记与清除
subtitle:   GC锁、可达性分析
date:       2021-08-03
author:     bbkgl
header-img: img/post-bg-0025.jpg
catalog: true
tags:
    - UE4
    - C++
---

> 故乡云水地
>
> 归梦不宜秋

继续接上文，分析UE GC的mark和sweep。

## 可达性分析

通过调用 `FRealTimeGC::PerformReachabilityAnalysis()` 实现对所有 UObject 的可达性分析。

```cpp
	void PerformReachabilityAnalysis(EObjectFlags KeepFlags, bool bForceSingleThreaded, bool bWithClusters)
	{
		/** Growing array of objects that require serialization */
		FGCArrayStruct* ArrayStruct = FGCArrayPool::Get().GetArrayStructFromPool();
		TArray<UObject*>& ObjectsToSerialize = ArrayStruct->ObjectsToSerialize;

		// Reset object count.
		GObjectCountDuringLastMarkPhase.Reset();

		// Make sure GC referencer object is checked for references to other objects even if it resides in permanent object pool
		if (FPlatformProperties::RequiresCookedData() && FGCObject::GGCObjectReferencer && GUObjectArray.IsDisregardForGC(FGCObject::GGCObjectReferencer))
		{
			ObjectsToSerialize.Add(FGCObject::GGCObjectReferencer);
		}

		{
			const double StartTime = FPlatformTime::Seconds();
			(this->*MarkObjectsFunctions[GetGCFunctionIndex(!bForceSingleThreaded, bWithClusters)])(ObjectsToSerialize, KeepFlags);
			UE_LOG(LogGarbage, Verbose, TEXT("%f ms for MarkObjectsAsUnreachable Phase (%d Objects To Serialize)"), (FPlatformTime::Seconds() - StartTime) * 1000, ObjectsToSerialize.Num());
		}

		{
			const double StartTime = FPlatformTime::Seconds();
			PerformReachabilityAnalysisOnObjects(ArrayStruct, bForceSingleThreaded, bWithClusters);
			UE_LOG(LogGarbage, Verbose, TEXT("%f ms for Reachability Analysis"), (FPlatformTime::Seconds() - StartTime) * 1000);
		}
        
		// Allowing external systems to add object roots. This can't be done through AddReferencedObjects
		// because it may require tracing objects (via FGarbageCollectionTracer) multiple times
		FCoreUObjectDelegates::TraceExternalRootsForReachabilityAnalysis.Broadcast(*this, KeepFlags, bForceSingleThreaded);

		FGCArrayPool::Get().ReturnToPool(ArrayStruct);

#if UE_BUILD_DEBUG
		FGCArrayPool::Get().CheckLeaks();
#endif
	}

```

注意到定义了一个 `FGCArrayStruct` 类型的局部变量 `ArrayStruct`，用于存储需要序列化的 UObject。这个变量通过 `FGCArrayPool::GetArrayStructFromPool()` 返回，在 `MarkObjectsAsUnreachable()` 也可以见到这样的用法。 `ArrayStruct->ObjectsToSerialize` 是一个长度持续增长的序列，在整个可达性分析的过程中存储所有可达的UObject指针。我感觉是通过存在这样的一个序列池，内存连续，用于在可达性分析阶段存储 `UObject` 指针，以减小cache miss。

首先将 `FGCObject::GGCObjectReferencer` 加入到了 `ObjectsToSerialize` 中， `FGCObject::GGCObjectReferencer` 是类 `FGCObject`  中的一个静态成员，其充当了一座联系  `FGCObject` 和 `UObject` 的桥梁，可以让继承于  `FGCObject` 的对象，通过调用 `AddReferencedObjects()` 将自己纳入到可达性分析中。其实就是可以让   `FGCObject` 子类的一些 `UObject` 成员可以被可达性分析判定为可达，防止成员中的 `UObject` 被清理掉，所以会看到类 `GGCObjectReferencer` 中有一个 `TArray<FGCObject *>` 的成员，用于可达性分析中遍历每个 `FGCObject` 对象。这件事虽然说起来简单，但UE中实现却相当复杂。

后面两处代码块中，一处会遍历所有的 `UObject`，试图将它们都标记为不可达，明确可达或者特殊的UObject的放入到 `ObjectsToSerialize` 中，所以可以看到传的是引用。

另外一处就是可达性分析，可达性分析中会逐渐将所有可达的 `UObject` 添加到 `ArrayStruct->ObjectsToSerialize` 中，不可达的则标记不可达。

