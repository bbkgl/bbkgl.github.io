---
layout:     post
title:      获取Lua的全局指针
subtitle:   profile
date:       2019-12-02
author:     bbkgl
header-img: img/post-bg-0007.jpg
catalog: true
tags:
    - profile
---

>微微风簇浪
>
>散作满河星

Lua是一种脚本语言，或者说一种嵌入式的语言。。Lua 解释器是一个使用 Lua 标准库实现的独立的解释器，她是
个很小的应用（总共不超过 500 行的代码）。解释器负责程序和使用者的接口：从使用者那里获取文件或者字符串，并传给 Lua 标准库，Lua 标准库负责最终的代码运行。 

## Lua解释器运行过程

#### Lua全局指针

Lua 库没有定义任何全局变量。它所有的状态保存在动态结构 lua_State 中，而且指向这个结构的指针作为所有 Lua 函数的一个参数。这样的实现方式使得 Lua 能够重入（reentrant）且为在多线程中的使用作好准备。 

#### Lua程序运行过程

函数 lua_open 创建一个新环境（或 state）。lua_open 创建一个新的环境时，这个环境并不包括预定义的函数，甚至是 print。为了保持 Lua 的苗条，所有的标准库以单独的包提供，所以如果你不需要就不会强求你使用它们。头文件 lualib.h 定义了打开这些库的函数。例如，调用 luaopen_io，以创建 io table 并注册 I/O 函数（io.read,io.write 等等）到 Lua 环境中。 

创建一个 state 并将标准库载入之后，就可以着手解释用户的输入了。对于用户输入的每一行，C 程序首先调用 luaL_loadbuffer 编译这些 Lua 代码。如果没有错误，这个调用返回零并把编译之后的 chunk 压入栈。（记住，我们将在下一节中讨论魔法般的栈）之后，C 程序调用 lua_pcall，它将会把 chunk 从栈中弹出并在保护模式下运行它。和luaL_laodbuffer 一样，lua_pcall 在没有错误的情况下返回零。在有错误的情况下，这两个函数都将一条错误消息压入栈；我们可以用 lua_tostring 来得到这条信息、输出它，用lua_pop 将它从栈中删除。 

#### Lua堆栈

Lua API 没有定义任何类似 lua_Value 的类型。替代的方案，它用一个抽象的栈在 Lua 与 C 之间交换值。。栈中的每一条记录都可以保存任何 Lua 值。无论你何时想要从 Lua 请求一个值（比如一个全局变量的值），调用 Lua，被请求的值将会被压入栈。无论你何时想要传递一个值给 Lua，首先将这个值压入栈，然后调用 Lua（这个值将被弹出）。我们仍然需要一个不同的函数将每种 C 类型压入栈和一个不同函数从栈上取值（译注：只是取出不是弹出），但是我们避免了组合式的爆炸（combinatorial  explosion）。另外，因为栈是由 Lua 来管理的，垃圾回收器知道那个值正在被 C 使用。  几乎所有的 API函数都用到了栈。正如我们在第一个例子中所看到的，luaL_loadbuffer 把它的结果留在了栈上（被编译的 chunk 或一条错误信息）；lua_pcall 从栈上获取要被调用的函数并把任何临时的错误信息放在这里。 

## 获取Lua全局指针

通过ptrace，可以根据进程PID读取进程状态和数据，并跟踪进程，也就是实现一个调试器。 通过 ptrace( PTRACE_PEEKDATA , pid, ... ); 或者 ptrace( PTRACE_PEEKTEXT,pid, ...); 读取进程中的内存或者寄存器中的值。 从这样的思路出发，我们就能读取进程中`lua_State *L`的值。先说到这里，等我真的实现了再来补。

```cpp
#include <iostream>
#include <sys/ptrace.h>
#include <array>
#include <sys/user.h>
#include <algorithm>
#include <iomanip>
#include <libunwind-ptrace.h>
#include <libunwind.h>
#include <sys/wait.h>
#include <cxxabi.h>
#include <lua/lua.h>

int wait4stop(pid_t pid) {
    int status = 99;
    do {
        if (waitpid(pid, &status, 0) == -1 || WIFEXITED(status) || WIFSIGNALED(status))
            return 0;
    } while(!WIFSTOPPED(status));
    return 1;
}

lua_State *get_backtrace(pid_t pid) {
    lua_State *lua_p = nullptr;
    unw_cursor_t cursor, resume_cursor;
    unw_context_t context;
    unw_word_t ip, sp, off;

    unw_addr_space_t addr_space = unw_create_addr_space(&_UPT_accessors, __BYTE_ORDER__);
    if (!addr_space)
        std::cerr << "Failed to create address space" << std::endl;

    unw_getcontext(&context);

    if (-1 == ptrace(PTRACE_ATTACH, pid, nullptr, nullptr))
        std::cerr << "Failed to ptrace" << std::endl;

    if (!wait4stop(pid))
        std::cerr << "wait SIGSTOP of ptrace failed" << std::endl;

    void *rctx = _UPT_create(pid);

    if (rctx == nullptr)
        std::cerr << "Failed to _UPT_create" << std::endl;

    if (unw_init_remote(&cursor, addr_space, rctx))
        std::cerr << "unw_init_remote failed" << std::endl;

    resume_cursor = cursor;

    const size_t bufflen = 1024;
    char *buff = new char[bufflen];

    do {
        char *name = "23333";
        unw_get_reg(&cursor, UNW_REG_IP, &ip);
        unw_get_reg(&cursor, UNW_REG_SP, &sp);

        // 获取函数名字
        int flag = unw_get_proc_name(&cursor, buff, bufflen, &off);
        if (0 == flag) {
            int status = 99;
            if ((name = abi::__cxa_demangle(buff, nullptr, nullptr, &status)) == 0)
                name = buff;

            if (std::string(name) == "lua_pcall") {
                uintptr_t rbp, rsp, rdi;
                unw_get_reg(&cursor, UNW_X86_64_RBP, &rbp);
                unw_get_reg(&cursor, UNW_X86_64_RSP, &rsp);
                unw_get_reg(&cursor, UNW_X86_64_RDI, &rdi);
                printf("ip: 0x%016lx, %s + 0x%016lx, sp: 0x%016lx\n", ip, name, off, sp);
                std::cout << std::hex << rbp << "->";
                std::cout << std::hex << rsp << std::endl;
                std::cout << std::hex << (int *)rdi << std::endl;
                lua_p = reinterpret_cast<lua_State *>(rdi);
                break;
            }
        } else printf("error!(%d)\n", flag);
    } while (unw_step(&cursor) > 0);

    delete[] buff;
    _UPT_resume(addr_space, &resume_cursor, rctx);
    _UPT_destroy(rctx);

    // 然后是将进程结束中断
    ptrace(PTRACE_DETACH, pid, nullptr, nullptr);

    return lua_p;
}

int main() {
    lua_State *lua_p = get_backtrace(1145572);
    std::cout << lua_p << std::endl;
    return 0;
}


// 23333
ip: 0x000055f676c05408, lua_pcall + 0x0000000000000058, sp: 0x00007ffd23ee9ce0
ffffffff->7ffd23ee9ce0
0x117ae5
0x117ae5
```

