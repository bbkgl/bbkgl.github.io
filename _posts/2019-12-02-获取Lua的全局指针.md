---
layout:     post
title:      获取Lua的全局指针
subtitle:   profile
date:       2019-12-02
author:     bbkgl
header-img: img/post-bg-0007.jpg
catalog: true
tags:
    - profile
---

>微微风簇浪
>
>散作满河星

Lua是一种脚本语言，或者说一种嵌入式的语言。。Lua 解释器是一个使用 Lua 标准库实现的独立的解释器，她是
个很小的应用（总共不超过 500 行的代码）。解释器负责程序和使用者的接口：从使用者那里获取文件或者字符串，并传给 Lua 标准库，Lua 标准库负责最终的代码运行。 

## Lua解释器运行过程

#### Lua全局指针

Lua 库没有定义任何全局变量。它所有的状态保存在动态结构 lua_State 中，而且指向这个结构的指针作为所有 Lua 函数的一个参数。这样的实现方式使得 Lua 能够重入（reentrant）且为在多线程中的使用作好准备。 

#### Lua程序运行过程

函数 lua_open 创建一个新环境（或 state）。lua_open 创建一个新的环境时，这个环境并不包括预定义的函数，甚至是 print。为了保持 Lua 的苗条，所有的标准库以单独的包提供，所以如果你不需要就不会强求你使用它们。头文件 lualib.h 定义了打开这些库的函数。例如，调用 luaopen_io，以创建 io table 并注册 I/O 函数（io.read,io.write 等等）到 Lua 环境中。 

创建一个 state 并将标准库载入之后，就可以着手解释用户的输入了。对于用户输入的每一行，C 程序首先调用 luaL_loadbuffer 编译这些 Lua 代码。如果没有错误，这个调用返回零并把编译之后的 chunk 压入栈。（记住，我们将在下一节中讨论魔法般的栈）之后，C 程序调用 lua_pcall，它将会把 chunk 从栈中弹出并在保护模式下运行它。和luaL_laodbuffer 一样，lua_pcall 在没有错误的情况下返回零。在有错误的情况下，这两个函数都将一条错误消息压入栈；我们可以用 lua_tostring 来得到这条信息、输出它，用lua_pop 将它从栈中删除。 

#### Lua堆栈

Lua API 没有定义任何类似 lua_Value 的类型。替代的方案，它用一个抽象的栈在 Lua 与 C 之间交换值。。栈中的每一条记录都可以保存任何 Lua 值。无论你何时想要从 Lua 请求一个值（比如一个全局变量的值），调用 Lua，被请求的值将会被压入栈。无论你何时想要传递一个值给 Lua，首先将这个值压入栈，然后调用 Lua（这个值将被弹出）。我们仍然需要一个不同的函数将每种 C 类型压入栈和一个不同函数从栈上取值（译注：只是取出不是弹出），但是我们避免了组合式的爆炸（combinatorial  explosion）。另外，因为栈是由 Lua 来管理的，垃圾回收器知道那个值正在被 C 使用。  几乎所有的 API函数都用到了栈。正如我们在第一个例子中所看到的，luaL_loadbuffer 把它的结果留在了栈上（被编译的 chunk 或一条错误信息）；lua_pcall 从栈上获取要被调用的函数并把任何临时的错误信息放在这里。 

## 获取Lua全局指针

通过ptrace，可以根据进程PID读取进程状态和数据，并跟踪进程，也就是实现一个调试器。 通过 ptrace( PTRACE_PEEKDATA , pid, ... ); 或者 ptrace( PTRACE_PEEKTEXT,pid, ...); 读取进程中的内存或者寄存器中的值。 从这样的思路出发，我们就能读取进程中`lua_State *L`的值。先说到这里，等我真的实现了再来补。


