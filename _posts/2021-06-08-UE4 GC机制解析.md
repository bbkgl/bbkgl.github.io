---
clayout:     post
typora-root-url: ..
title:      UE4 GC机制解析（一）
subtitle:   GC概述
date:       2021-06-08
author:     bbkgl
header-img: img/post-bg-0023.jpg
catalog: true
tags:
    - UE4
    - C++
---

> 难顶

## GC简介

标记-清除算法。

## UE4 GC概述

#### 如果要实现标记-清除的垃圾回收机制？

试想，如果要实现类似于JVM的垃圾回收机制，从数据的收集开始，要设计并实现哪几个过程？

首先肯定是收集所有需要GC的对象的内存地址，这个过程需要在对象刚生成的时候进行，可以放在构造函数内（需要统一继承Object对象），或者是在某种统一的构造过程内进行。

其次是 **GC对象有向图** 的构造。在其他高级语言中，通常把无引用或者没有被任何指针指向的对象，视为需要被回收的对象，要能够查找到这些需要被回收的对象，则需要构造有向图。同时，在有向图中，也将这样的结点视为不可达结点或者是不可达对象。这里构造有向图时，存在两个问题：

- 对于每个对象，如何找到并记录成员的类型和地址？
- 是否要记录所有成员的信息？

这两个问题也是UE4 GC与其他高级语言GC机制的重要区别，其他语言通常有反射和虚拟机支持，获取这些信息相对简单，那主流的C++实现没有这些动态机制，又如何做到呢，先卖个关子2333。

在清扫对象（垃圾）前，需要进行垃圾标记。垃圾标记的过程就是从根结点，遍历整个有向图，将遍历到的所有结点标记为可达（非垃圾）。于是在整个对象数组中，则认为不可达对象均为垃圾对象，需要清理。

最后遍历整个对象数组，清理垃圾。

#### UE4 GC的技术

前面文章中已经解析了UE4的反射实现，所以对于上面两个问题，反射基本能解决大半。

- 反射可帮助获取对象成员信息
- 并不是所有成员都需要记录在有向图上参与GC，基础类型如int，float等直接存储在对象的连续内存上，在回收对象内存时，这些基础类型成员就被一同回收。

所以问题转移，如何判断成员是否要挂在有向图上作为结点参与GC呢？

后续通过源码进行详细解析，当然还有其它问题，包括簇，多线程GC，分帧GC等。
