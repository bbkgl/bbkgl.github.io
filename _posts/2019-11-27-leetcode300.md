---
layout:     post
title:      300. Longest Increasing Subsequence
subtitle:   我太难了
date:       2019-11-27
author:     bbkgl
header-img: img/post-bg-00012jpg
catalog: true
tags:
    - leetcode
---

>寒灯纸上梨花雨凉
>
>我等风雪又一年

C++，动态规划。

#### 动态规划

纯动态规划十分的简单，就是用数组dp记录上升序列的长度，`dp[i]`就表示以i为结尾的最长上升子序列，于是就能得到状态转移方程：

$$dp(i) = max\{dp(i), dp(j) + 1\} ,j < i$$

用代码来表示也是非常简单，对每个元素，遍历在此之前的所有元素，然后看能不能以当前元素作为“最长上升子序列”的尾巴，并选取最长的一个进行组合。

所以就能写出代码了：

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int> &nums) {
        if (nums.empty()) return 0;
        vector<int> dp(nums.size(), 1);
        int ans = 0;
        for (int i = 0; i < nums.size(); i++) {
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i])
                    dp[i] = max(dp[i], dp[j] + 1);
            }
            ans = max(ans, dp[i]);
        }
        return ans;
    }
};
```

#### 动态规划+二分

